Esteira DevOps — Jenkins + Docker (CI/CD) com PostgreSQL

Integrantes: ________________________________________________

1) Integração Contínua (CI)
1.1 Objetivo

Garantir que a aplicação Flask seja construída a cada commit, com validação mínima de dependências e build das imagens Docker.

1.2 Stages e Evidências

Cleanup — limpeza do workspace e camadas Docker antigas.
(Print do console do Jenkins com docker system prune)

Checkout — código baixado do SCM.
(Print do changelog do Jenkins)

Construção — docker build da imagem web + teste rápido (import flask, sqlalchemy).
(Print do console com sucesso)

1.3 Pipeline (Jenkinsfile)

O Jenkinsfile executa os estágios: Cleanup → Checkout → Construção → Entrega.

2) Entrega Contínua (CD)
2.1 Objetivo

Subir o ambiente de homologação via docker compose, expondo a aplicação em http://localhost:8200 (web) e 5433 (Postgres).

2.2 Stages e Evidências

Entrega — docker compose up -d --build com db (PostgreSQL), web (Flask) e jenkins.

(Print do docker ps com os 3 containers: db, web, jenkins)

(Print do navegador com “Funciona!” em http://localhost:8200/)

2.3 Arquivos de Infra

docker-compose.yml — orquestra Postgres, Web e Jenkins

Dockerfile.web — imagem da aplicação Flask

codigo.sql — seed executado automaticamente no Postgres

requirements.txt, main.py

3) Como executar
# Build e subida
docker compose up -d --build

# Verificar containers
docker ps

# Testar aplicação
curl http://localhost:8200/
# ou abrir no navegador

4) Perguntas

1. Como a automação (CI/CD) ajuda no longo prazo?

Feedback contínuo a cada commit (quebras detectadas cedo).

Padroniza builds e deploys, reduzindo erros humanos.

Logs e artefatos versionados → rastreabilidade e rollback.

Encoraja testes, lint e scans automáticos → qualidade e segurança.

Libera tempo do time para tarefas de maior valor.

2. Como poderíamos realizar telemetria do pipeline?

Jenkins + Prometheus (plugin) → métricas de builds (status, duração, fila) exibidas no Grafana (DORA: Lead Time, MTTR, CFR).

Logs do console enviados a ELK/OpenSearch com alertas (ex.: falha no estágio Construção).

Notificações via Slack/Email/Webhooks a cada mudança de estado.

Auditoria (aprovadores, gatilhos manuais, autoria dos deploys).

5) Checklist de Evidências (anexar prints)

 Console do Jenkins (Cleanup)

 Changelog do SCM (Checkout)

 Build concluído (Construção)

 docker ps com containers db/web/jenkins

 Navegador em http://localhost:8200/ com “Funciona!”